# This script should be sourced, not executed
# Can be sourced in bash or zsh
# vim: filetype=bash

SECONDS=0
redc=$(tput setaf 1)
gren=$(tput setaf 2)
yelw=$(tput setaf 3)
norm=$(tput sgr0)
if [[ -z $XDG_STATE_HOME ]]; then
  export XDG_STATE_HOME="/home/$USER/.local/state"
fi
if [[ ! -d $XDG_STATE_HOME ]]; then
  mkdir -p $XDG_STATE_HOME
fi
if [[ ! $(command -v gum) ]]; then
  alias gum='~/.dotfiles/bin/$(arch)/gum'
fi

# Update packages
eval "$(source /etc/os-release && typeset -p ID)"
if [[ $ID =~ ^(rhel|fedora|amzn|ol|rocky)$ ]]; then
  [[ $ID == ol ]] && repo=ol9_developer_EPEL
  sudo dnf config-manager --set-enabled $repo
  sudo dnf upgrade -y || \
    { echo "${redc}Failed: packages update${norm}" >&2; return 1; }
elif [[ $ID =~ ^(debian|ubuntu|pop|raspbian)$ ]]; then
  gum spin --spinner.width=1 \
    --title "Updating package information from sources" --show-output -- \
    sudo apt-get update -qq && \
    sudo apt-get upgrade -y && \
    sudo apt autoremove -y || \
    { echo "${redc}Failed: packages update${norm}" >&2; return 1; }
fi

# Pull dotfiles origin/master
git -C ~/.dotfiles remote update
[[ $(git -C ~/.dotfiles rev-parse HEAD) == \
  $(git -C ~/.dotfiles ls-remote $(git -C ~/.dotfiles rev-parse --abbrev-ref '@{u}' | \
  sed 's/\// /g') | cut -f1) ]] && echo Local repository is up to date || \
  echo Local repository has diverged from remote. Updating now.. && {
    git -C ~/.dotfiles diff-index --quiet HEAD || stash=true
    [[ $stash ]] && git -C ~/.dotfiles stash push --quiet
    git -C ~/.dotfiles pull --no-ff
    [[ $stash ]] && git -C ~/.dotfiles stash pop --quiet
    unset stash
  }

# Install/uninstall some native packages
[[ $ID =~ ^(rhel|fedora|amzn|ol|rocky)$ ]] && pkmngcmd='dnf'
[[ $ID =~ ^(debian|ubuntu|pop|raspbian)$ ]] && pkmngcmd='apt-get'
if [[ $pkmngcmd ]]; then
  if ! cmp --silent ~/.dotfiles/packages $XDG_STATE_HOME/bootstrap_packages; then
    source ~/.dotfiles/packages; sudo $pkmngcmd install -y -- "${packages[@]}" || \
      { echo "${redc}Failed: package installation${norm}" >&2; return 1; }
    installed=("${packages[@]}") && unset packages
    removed=("${rmmvpkgs[@]}") && unset rmmvpkgs
    if [[ -e $XDG_STATE_HOME/bootstrap_packages ]]; then
      source $XDG_STATE_HOME/bootstrap_packages
      for i in "${installed[@]}"; do packages=("${packages[@]//*$i*}"); done
      for k in "${removed[@]}"; do rmmvpkgs=("${rmmvpkgs[@]//*$k*}"); done
      sudo $pkmngcmd remove -y -- "${packages[@]}" "${rmmvpkgs[@]}" || \
        { echo "${redc}Failed: package removal${norm}" >&2; return 1; }
    fi
    command cp ~/.dotfiles/packages $XDG_STATE_HOME/bootstrap_packages
    unset packages rmmvpkgs installed removed
  fi
  unset pkmngcmd
fi

# Install/update nix package manager
# and install/uninstall packages, but not on Android
if [[ ! $(command -v nix) ]] && [[ $(uname -o) != Android ]]; then
  sudo mkdir /etc/nix
  sudo sh -c 'printf "%s\n%s\n" \
    "use-xdg-base-directories = true" \
    "experimental-features = nix-command flakes" \
    > /etc/nix/nix.conf'
  { gum spin --spinner.width=1 --title "Installing nix package manager" -- \
    sh <(curl -sL https://nixos.org/nix/install) --yes --no-modify-profile && \
    echo Nix package manager installed; } && \
    source $XDG_STATE_HOME/nix/profile/etc/profile.d/nix.sh || \
    { echo "${redc}Failed: nix package manager installation${norm}" >&2; return 1; }
fi
nix-channel --add https://nixos.org/channels/nixos-23.05 stbpkgs
nix-channel --update
{ gum spin --spinner.width=1 --title "Nix garbage collecting" --show-output -- \
  nix-collect-garbage --delete-old && \
  echo Nix garbage collected; }
# Intall & uninstall nix packages
if ! cmp --silent ~/.dotfiles/nix.pkgs $XDG_STATE_HOME/nix_packages; then
  source ~/.dotfiles/nix.pkgs
  newpkgs=("${nixpkgs[@]}") && unset nixpkgs
  if [[ -e $XDG_STATE_HOME/nix_packages ]]; then
    source $XDG_STATE_HOME/nix_packages
    oldpkgs=("${nixpkgs[@]}") && unset nixpkgs
    newpkgs=($(comm -2 -3 <(printf "%s\n" "${newpkgs[@]}" | sort) \
      <(printf "%s\n" "${oldpkgs[@]}" | sort) | sort -n))
  fi
  export NIXPKGS_ALLOW_UNFREE=1
  for addpkg in "${newpkgs[@]}"; do
    if [[ $addpkg != ${addpkg#nixpkgs.} ]]; then
      nix-env -iA $addpkg \
        && echo "${gren}${addpkg#nixpkgs.} installed${norm}" || \
        { echo "${redc}Failed: ${addpkg#nixpkgs.} nix package installation${norm}" >&2
        return 1; }
    elif [[ $addpkg != ${addpkg#stbpkgs.} ]]; then
      nix-env -iA $addpkg \
        && echo "${gren}${addpkg#stbpkgs.} (stable channel) installed${norm}" || \
        { echo "${redc}Failed: ${addpkg#stbpkgs.} nix package installation${norm}" >&2
        return 1; }
    fi
  done
  unset newpkgs
  if [[ -e $XDG_STATE_HOME/nix_packages ]]; then
    source $XDG_STATE_HOME/nix_packages
    oldpkgs=("${nixpkgs[@]}") && unset nixpkgs
    source ~/.dotfiles/nix.pkgs
    newpkgs=("${nixpkgs[@]}") && unset nixpkgs
    oldpkgs=($(comm -1 -3 <(printf "%s\n" "${newpkgs[@]}" | sort) \
      <(printf "%s\n" "${oldpkgs[@]}" | sort) | sort -n))
    for rempkg in "${oldpkgs[@]}"; do
      if [[ $rempkg != ${rempkg#nixpkgs.} ]]; then
        nix-env --uninstall ${rempkg#nixpkgs.} \
          && echo "${yelw}${rempkg#nixpkgs.} uninstalled${norm}" || \
          { echo "${redc}Failed: ${rempkg#nixpkgs.} nix package removal${norm}" >&2
          return 1; }
      elif [[ $rempkg != ${rempkg#stbpkgs.} ]]; then
        nix-env --uninstall ${rempkg#stbpkgs.} \
          && echo "${yelw}${rempkg#stbpkgs.} (stable channel) uninstalled${norm}" || \
          { echo "${redc}Failed: ${rempkg#stbpkgs.} nix package removal${norm}" >&2
          return 1; }
      fi
    done
    unset oldpkgs
  fi
  command cp ~/.dotfiles/nix.pkgs $XDG_STATE_HOME/nix_packages
fi

# Install Hashicorp repository
sudo ~/.dotfiles/bin/scripts/repo-add-hashcorp.sh

# Change default shell to zsh if it is not
if [[ $(basename "$(grep $(whoami) /etc/passwd)") != zsh ]]; then
  sudo chsh --shell /bin/zsh $(whoami)
  echo "${yelw}Default shell changed to z-shell${norm}"
fi

# Setup/update antidote
if [[ $ZSH_VERSION ]]; then
  if [[ ! -d ~/.cache/antidote ]]; then
    git clone --depth=1 https://github.com/mattmc3/antidote.git ~/.cache/antidote
  fi
  source ~/.cache/antidote/antidote.zsh
  antidote load ~/.dotfiles/config/.includes/zsh_plugins.txt
  antidote update | grep -Ev "(^antidote: checking for updates|^$)"
fi

# Stow binaries
if [[ $UID -ne 0 ]] && [[ $EUID -ne 0 ]]; then
  gum spin --spinner.width=1 --title "Stowing binaries" -- \
    sudo ~/.dotfiles/bin/scripts/stow-bin.sh && \
    echo "Binaries stowed" || \
    { echo "${redc}Failed: stow-bin.sh${norm}" >&2; return 1; }
else
  gum spin --spinner.width=1 --title "Stowing binaries" -- \
    ~/.dotfiles/bin/scripts/stow-bin.sh --nosudo && \
    echo "Binaries stowed" || \
    { echo "${redc}Failed: stow-bin.sh${norm}" >&2; return 1; }
fi

# Stow dotfiles
gum spin --spinner.width=1 --title "Stowing dotfiles" -- \
  ~/.dotfiles/bin/scripts/stow-dotfiles.sh && \
  echo "Dotfiles stowed" || \
  { echo "${redc}Failed: stow-dotfiles.sh${norm}" >&2; return 1; }

# On WSL do all sorts of other stuff
if grep -qi microsoft /proc/version; then
  gum spin --spinner.width=1 --title "Configuring Windows" -- \
    ~/.dotfiles/bin/scripts/dotfiles2appdata.sh && \
    echo "Windows configured" || \
    { echo "${redc}Failed: Windows configuration${norm}" >&2; return 1; }
fi

# Check for new kernel
if ! grep -qi microsoft /proc/version; then
  ~/.dotfiles/bin/scripts/kernel-update-check.sh
fi

# Check if repository is encryption locked
git config -f ~/.dotfiles/.git/config --get filter.git-crypt.smudge >/dev/null || \
  echo "${yelw}Repository is locked${norm}"

# Print time taken
printf 'Time taken %d:%02d:%02d\n' \
  $((SECONDS/3600)) $(((SECONDS/60)%60)) $((SECONDS%60))

# Initialise shell
if [[ $BASH_VERSION ]]; then
  exec bash
elif [[ $ZSH_VERSION ]]; then
  exec zsh
fi
